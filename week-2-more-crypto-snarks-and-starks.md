# Week 2 さらなる暗号技術とSNARKsとSTARKs

## CircomのTIPS

### コーディング

`template` : 回路のテンプレート。インスタンス化されることで回路のオブジェクトになる。

`include` : 外部のテンプレートをインポートする。

`component` : テンプレートをインスタンス化する。

`signal input` : テンプレートに入力される値。

`signal output` : テンプレートから出力される値。

`signal` : `signal input` の値によって変化する変数を定義する。

`var` : `signal input` の値によって変化しない変数を定義する。

`<--` : シグナルに代入する。

`<==` : シグナルに代入しつつ、両辺が等しいという制約をR1CSに追加する。基本的に `<--` ではなくこちらの使用が推奨される。

### Circom特有の注意点

**ハッシュ関数**

circomでは値を有限体の算術回路として計算するため、ビット演算では制約が増加し、通常よりも計算量が増えます。これは使用するハッシュ関数の選定時にも重要な点で、Solidityでも使用されるkeccak-256はビット演算のため、Circomでは扱いづらいです。

そのためCircomでは有限体上で計算する以下のようなハッシュ関数が好まれます。

- Poseidon: zkSNARKで最も効率的に動作。回路内での成約数を最小限に抑える設計。
- MiMC: zkSNARKで効率的に動作。ラウンド数等のパラメータを選択できる。
- Pedersen: 楕円曲線を使用したPedersenコミットメントに基づく。加法準同型性を持つ。

zkSNARKでは、特にPoseidonハッシュがよく利用されます。

**分岐とループ**

Circomのコードは算術回路などに変換された後、証明者と検証者に渡されるため、証明者から入力される `signal input` によって算術回路の構造を後からダイナミックに変化させることはできません。

つまり、分岐やループの条件部分など、算術回路の構造に影響を与えるような部分のCircomのコードでは、 `signal` の値を直接利用することができません。

例えば、if文で `signal` の値により分岐させたい場合には、どちらの分岐も計算され両方の和が計算されるものの、条件により分岐の片方の計算結果は0になるようにコードを書く必要があります。

これを実現するために、以下の2つの段階が必要です。

- 分岐ごとに、`signal` と比較する値が入力され、それぞれに対して0か1が出力される
- 前述の出力（0か1の値）と各分岐の計算結果が入力され、計算結果と前述の出力の組のどちらかの積が0となり2組の和が計算されるように出力される

前者には `IsEqual` や `LessThan` 等のテンプレートがあり、後者はシンプルな分岐の場合には容易に自身で書くこともできますが、 `Mux1` テンプレート等が利用できます。

```
signal input in;
signal output out;

component isEq = isEqual();
isEq.in[0] <== in;
isEq.in[1] <== 7; // 比較する値

component mux = Mux1();
mux.s <== isEq.out;
mux.c[0] <== 0; // 条件と一致しないとき
mux.c[1] <== 777; // 条件と一致するとき
out <== mux.out;
```

## Tornado Cash

Tornado Cashは、ZKによってプライバシーを保護した送金を可能にする分散型プロトコルです。

旧バージョンのTornado Cash Classicと2021年リリースのTornado Cash Novaの2種類があります。

### 概要（ClassicとNovaに共通）

送金するETHアドレス（Alice）と受け取るETHアドレス（Bob）の間のオンチェーン上での関係性を、第三者に分からないようにすることで、プライバシー送金を実現します。

具体的には、AliceがBobに直接送金するのではなく、Aliceがプールコントラクトに入金し、Bobがプールコントラクトから出金します。

プールコントラクトの利用者がAliceとBob以外にも多く存在し、かつ各入出金ペアの関係性が分からないとき、プライバシーを保つことができます。（ミキシング）

この状況下で、Aliceが入金したトークンをBobが出金できるようにするために、ZK（zkSNARKであるGroth16）とマークルツリーを使用しています。

### Classicの特徴

Classicでは、各入金に対して秘密の文字列（プライベートノート）を生成し、出金時にそれを入力させることで、正しい出金者かを検証します。

このプライベートノートの検証にZKを使うことで、チェーン上のプールコントラクトで送金者を検証できます。

しかし、以下のような欠点もあります。

- 何らかの安全な方法でプライベートノートを出金者に伝える必要がある
- 出金のタイミングや金額を他の利用者とある程度合わせなければ、ミキシングの効果が薄れてしまう

### Novaの特徴

ここでは、Classicからのいくつかの変更のうち、ミキシングに関連する部分を解説します。

Novaでは上記のようなClassicの欠点を改善するために、プライベートノートではなく、各ユーザーのアカウントごとの残高と直前の入出金額の記録（アカウントベースのUTXO）を、入出金の度に更新していくように変更されました。

AliceからBobにプライベート送金をしたい場合には、以下のフローに従います。

1. AliceとBobが秘密鍵を生成し、公開鍵をコントラクトに送る（アカウント作成）
2. Aliceは自身の秘密鍵とAliceとBobのUTXO（初回は残高０）等から、UTXOの金額等を検証するためのZKの証明を作成し、プールコントラクト上で検証と入金を行う
3. BobはAliceが入金したときと類似の方法（秘密鍵とUTXOの証明）で出金する

この変更により、プールコントラクト上でアカウントベースで資金を記録できるようになり、出金額を入金額と異なる金額に設定可能になったため、ミキシングの効果が高まり、より自由度の高い取引が実現しました。

### リレーヤーの役割

ここまでは、ユーザーのクライアント上での秘匿化とそれがコントラクトでどのように検証・入出金されるかを確認してきました。

しかし、まだ出金側のアドレスに出金のトランザクションを実行するためのガス代が必要になるという問題があります。つまり匿名送金を受け取りたいのに、そのためには匿名ではない資金が必要になってしまうという矛盾が発生することになります。

これを解決するために、ユーザーはリレーヤーにトランザクションの実行を代理するように依頼できます。

リレーヤーは出金のトランザクション時にその金額の一部を手数料として受け取ることができます。